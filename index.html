<!DOCTYPE html>

<html>

<head>
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>

<!-- sidebar -->
<div class="clearfix">
  <div class="column sidemenu">
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#designrecipe">The Design Recipe</a></li>
      <li><a href="#stop-sign">Stop Sign</a></li>
      <li><a href="#counterchange">Counter-Change</a></li>
      <li><a href="#bulls-eye">Bulls-Eye</a></li>
      <li><a href="#pinwheel">Pinwheel</a></li>
      <li><a href="#business-card">Business Card</a></li>
      <li><a href="#clock-face">Clock Face</a></li>
    </ul>
  </div>

  <div class="column content">
    <div class="header">
      <h1>
        <img src="https://racket-lang.org/img/racket-logo.svg" width="25px"/>
        Building Pictures with Racket
      </h1>
        <p style="text-align:center;">
        <i>By Rowan Weir, Daniel Barnas, Allan Schougaard</i>
        </p>
      </div>

<!-- ADD SOURCE FILES FOR ALL EXAMPLES AND CHALLENGES -->

<!-- INTRODUCTION -->

<h2 id="introduction"> Introduction</h2>

<p>
    So far, we have focused on building images with pre-existing functions from the 2htdf/image and picturing-programs libraries.
    We are going to utilize what we have covered previously in this chapter, so review the chapter on graphics first (here). <!-- insert link to previous chapter in github-->
    In this chapter, we are going to define functions that accept images as arguments or return an image output.
</p>


<!-- SECTION 1 -->

<h2 id="designrecipe">The Design Recipe</h2>

<!-- Insert ordered list-->

<p>
  Designing functions can be complicated, but the process is simplified using a 'design recipe'.
  A design recipe is a step-by-step process that precisely articulates how to build or define functions.
  We will be going over each step of the recipe in detail in this chapter.
</p>
<p>
  It is possible to cobble together a function from bits and pieces of code, approaching the problem arbitrarily and forcing the function to work via brute force.
  Although this haphazard approach to programming may succeed on smaller, less sophisticated functions, functions with this programming "philosophy" at their core are ultimately more difficult to develop.
</p>
<p>
  In the world of software development, projects often require the coordinated cooperation of many people.
  For this reason, it is important to clarify exactly what a program will be expected to do, and what the inputs are, and what the expected output will be.
  Therefore a systematic recipe for writing functions is incredibly valuable.
</p>
<p>
  The design recipe also allows for a divide-and-conquer approach, breaking large problems into smaller ones.
  It also requires you to more completely understand and express different aspects of your function.
</p>
<p>
  The steps in the design recipe can be broken down as follows:
  <ol>
    <li>Purpose</li>
    <li>Signature</li>
    <li>Examples</li>
    <li>Stub</li>
    <li>Template</li>
    <li>Code</li>
  </ol>
</p>

<!-- SECTION 1.1 -->

<h3 id="Purpose">Purpose</h3>

<p>
  The first step of writing any function is to clarify and express exactly what you intend to the function to do.
  That is the concept behind the purpose statement.
  At first, you will probably want to jump in and begin coding right away.
  What you may find later on, however, is that you do not fully understand the specifics of what your function is supposed to do, or what components you may need to complete it.
  Stating the purpose of our function forces us to confront our understanding of the task at hand.
  You may also find that putting the problem you're trying to solve into words
  automatically deepens your understanding of the problem.
  A good purpose statement succinctly explains what the function will accept as arguments, what it will do, and what it will output, if anything.
</p>
<p>
  Let's try writing some good purpose statements.
  For simplicity, in these first examples we are going to use numbers.
  Later, we will explore how the same process can apply to graphics.
  <br>
  Here is our challenge:
  <code class="block">
    Create a function that squares any number.
  </code>
  A good way to begin writing purpose statements is to follow this basic format:
  <code class="block">
    ; Purpose : Given ..., returns ...
  </code>
  What you are <i>given</i> is your input.
  What you <i>return</i> is the function's expected output.
  <br>
  This may seem overly simplified, but knowing these two components of your function from the very beginning can really help you a great deal later on.
  <br>
  For the purpose statement of this function, we could write the following:
  <code class="block">
    ; Purpose : Given any number, returns that number raised to the second power.
  </code>
  Keep in mind that a purpose statement should be fairly short, around 1-2 lines of comments.
  If you find yourself needing more than that, it may be a sign that the function you're trying to write could be broken up into smaller functions.
  If you cannot clearly and succinctly come up with a purpose statement that fits within two lines, the function you are trying to write can likely be broken down into a few functions of lesser complexity.
  <div class="question">
    Consider a pre-existing function that you already know. If you were to write that function, what might the purpose statement be?
  </div>
  <div class="question">
    What about a graphics function, like <code>overlay</code> or <code>rotate</code>?
  </div>
</p>

<!-- SECTION 1.2 -->

<h3 id="Signature">Signature</h3>

<p>
  After you have clarified the the purpose of your function, you need to specify the signature.
  A signature is like your toolbox.
  It clearly states what datatypes our program will be utilizing.
  The signature can also serve as a set of instructions for constructing parts of our function.
  When writing your signature, ask: what are we working with?
  What data am I starting with, and what do I want to get back?
 <br>
 Let's proceed with our example to get a better idea of what a signature should look like.
 <code class="block">
   ; Signature : Number &rarr; Number
 </code>
 Note the arrow seperating our two datatypes.
 The presence of the arrow indicates the datatype(s) on the left side are what we expect to input, and the type(s) on the right are what we expect the output to be.
 It is another way of saying <code> Given ... &rarr; Returns ... </code>
 Note also the capitalization of Number and Number.
 Capitalization in the signature denotes a datatype in these notes.
 <br>
 Our function accepts a number, and is expected to produce a number as well.
 Specifying the signature of a pre-existing function can be a way to better understand what that function does.
 For example, the signature of the <code> place-image </code> would be:
 <code class="block">
   ; Signature : Image Number Number Image &rarr; Image
 </code>
 <div class="question">
   What would the signature be for a graphics function that produces a shape, like <code> ellipse </code> or <code> radial-star </code>?
 </div>
</p>

<!-- SECTION 1.3 -->

<h3 id="Examples">Examples</h3>

<p>
  Testing is a vital component of the function design process.
  Creating effective examples of your function allows you to determine whether it is working as anticipated.
  Tests also serve the purpose of outlining the exact specifications of the function you plan to write.
  By demonstrating how you want your function to handle various inputs, you are defining requirements.
  A popular term for this is Test-Driven Development (TDD).
  <br>
  It is important to write examples prior to coding your function, because you will continually test your program as you add more to the code.
  <br>
  The function is most commonly used in Racket to create tests is <code>check-expect</code>.
  The check-expect function receives the name of your function and test arguments for each datatype you specified in your signature.
  It also includes the result you expect from your function, given the inputs provided.
  If we were to write the signature for the <code>check-expect</code> function, it might be:
  <code class="block">
    ; Signature : your-function datatype(s) expected-result &rarr; boolean
  </code>
  Remember, the number of inputs and the datatypes of the inputs and output should match the signature you wrote for your function.
  <br>
  Since the <code>check-expect</code> function requires the name of your function, this is our first opportunity to come up with a good name for the function we are designing.
  A good practice for function naming is to follow the verb-noun form.
  This convention includes a verb to denote the action your function is taking, and a noun to denote what is being acted upon.
  This function, for example, might be called square-number.
  Squaring is the action we are taking, and a number is what we are squaring.
<p/>
<p>
  Let's see how <code>check-expect</code> applies to our square-number function.
  <code class="block">
    ; Examples :
    (check-expect (square-number 3) 9)
  </code>
  The first argument is the square-number function that we are testing and our test input 3.
  The last argument is the expected output given the input, in this case 9.
  <br>
  Now, this test alone does not cover all scenarios our function needs to handle.
  We need to create additional test cases for all the conditions we expect our function to encounter.
  <code class="block">
    ; Examples :
    (check-expect (square-number 3) 9)
    (check-expect (square-number 0) 0)
    (check-expect (square-number -4) 16)
  </code>
  This will ensure that all parts of our function works.
  As mentioned earlier, <code>check-expect</code> is the function most commonly used to test examples, but there are others.
  It is sufficient for the needs of this chapter, and for most functions that will output images.
  If you'd like to learn more about other test functions, be sure to check out the documentation regarding <code>check-within</code>, <code>check-random</code>, and <code>check-satisfied</code>.
</p>

<!-- SECTION 1.4 -->

<h3 id="Stub">Stub</h3>

<p>
  With our test functions written and our desired outputs specified, it's time for the stub.
  The stub is like an extremely abbreviated version of what will eventually be our complete function.
  Consider it a first draft, the chief purpose of which is to get our examples to execute.
  <br>
  Most of the stub is written like a full function definition.
  Begin with the name of the function you are working on as well as any parameters representing the inputs that the function will take.
  Remember, these should match the inputs noted in the signature up above.
  <br>
  If we can get the test functions to run, even if they fail, we are still closer to our goal than if the test functions failed to run at all.
  For this reason, we include some bogus value instead of a full function body, preferably of the same data type as the function's expected output.
  We want to enter a bogus value to eliminate the chance that our tests will pass.
  <br>
  Let's see what a stub would look like for our example:
  <code class="block">
    ; Stub :
    (define (square-number num) -1)
  </code>
  We know the value -1 will never be an actual result, since the result of <code>square-number</code> will never be negative.
  <br>
  Run the stub.
  <div class="question">
    What happens? Is the result what we anticipated?
  </div>
</p>

<h3 id="Template">Template</h3>

<p>
  The next step in the HtDF recipe is the template.
  The template is a basic skeleton of our full function.
  We can outline the basic format and components without being concerned with precise details.
  The template also functions as a sort of inventory, where we take stock of what datatypes and functions are available to us, and decide which we may want to use to construct our function.
  The convention for writing a template is to <!-- establish template convention, write ellipses, you can start with parameters first or with functions, either way it needs  to be an outline for your function -->
</p>
<p>
  In the case of our <code>squared</code> function, we know that when squaring a number, you multiply it by itself.
  So, we know we will likely need to use <code>*</code>, the multiplication function.
  <code>*</code> requires two arguments, but we don't need to be specific yet, so we can just include <code>...</code> where those inputs will go.
  <code class="block"> <!-- at this stage you can check that your format or syntax is correct, you can run the template and it will tell you if parentheses are in the right place -->
    (define (square-number num)
      (* ... ...)
    )
  </code>
  In the next section, we will fill out the gaps in our template.
</p>

<h3 id="Code">Code</h3>

<p>
  At this point, we have worked our way through all the necessary preparations required for our code.
  We have succinctly stated the purpose of the function in a clear and understandable way and thought through the input and output datatypes we expect our function to use.
  We also outlined exactly what our function should return in a few critical test cases.
  Now that we have a basic outline for our function, we can move on to the coding step.
</p>
<p>
  Looking at our template, what arguments should we replace the <code>...</code> spaces with?
  <code class="block">
    ; Code :
    (define (squared num)
      (* num num)
    )
  </code>
</p>
<p>
  No we can run our code and see if our function passes the tests we set.
</p>
<!-- Section 2 -->

<h2 id="stop-sign"> Stop Sign </h2>

<p>
  Stop signs are ubiquitous, and generally share the same distinctive design regardless of the country they appear in.
  A red octogon accompanied by white text is the international standard.
  Many countries use the English word "STOP" on their signs, with others electing to use their local language instead.
</p>
<p>
  In this example, we want to write a function that produces a stop sign.
  This function will take a text input, and return the image of a stop sign with the text displayed in white letters.
  <code class="block">
    Create a function that produces the image of a stop sign, with text determined by the user.
   </code>
  Let's apply the design recipe to this problem.
  Recall that for the purpose statement, we want to briefly explain what our function will return, and which inputs it will require.
  <code class="block">
    ; Purpose : Given a string of text, return the image of a stop sign displaying that text.
  </code>
  The general idea behind our function is pretty simple.
  When given a string of text, the function should return a stop sign with that text on it.
  Our requirements for this function are made clear by the purpose statement, so we can write the signature right away.
  <code class="block">
    ; Signature : String &rarr; Image
  </code>
  This signature gives us a very basic form of how our function will be used, in addition to stating the input and output type(s) we are expecting to use and produce.
</p>
<p>
  The <code>check-expect</code> function that we use to test our functions requires a specific example of an input value and the output value that would result.
  This is not generally problematic when writing functions that contain simple datatypes such as numbers or strings, but can be more difficult when our expected output is an image.
  One way to utilize the <code>check-expect</code> function in this context is to create the image our function will produce prior to coding the function itself.
  This gives you a finished example that you can then test your function against.
  <br>
  For detailed information on how to produce images themselves, see our previous chapter. <!-- Link to previous chapter. -->
  <br>
  As we want to test stop signs in other languages as well, we should create another stop sign with the word "ALTO".
  You can find both examples here, if you want to use them in our own testing. <!-- Place TRY IT with code here -->
</p>
<p>
  Now that we have our example images, we can write the tests for our function.
  We also want to pick a descriptive name, using the verb-noun naming convention.
   <code class="block">
     ; Examples :
    (check-expect (make-stop-sign "STOP") <img src="images/stop-sign.png" width="20%"> )
   </code>
  The last argument that check-expect takes is the expected result of the function call.
  In this case, we can either copy and paste the image itself, or the code used to create the image.
  These are ultimately equivalent so the choice is up to you.
</p>
<p>
  Usually, the more test cases we provide, the better.
  We've already created a Spanish language stop sign, so let's make a test featuring that image as well.
  <code class="block">
    ; Examples :
    (check-expect (make-stop-sign "ALTO") <img src="images/alto-sign.png" width="20%"> )
  </code>
</p>
<p>
  Next, we write the stub.
  Remember that the stub mimics a full function definition, with a bogus value in place of code.
   <code class="block">
     ; Stub :
    (define (make-stop-sign str) "stop-sign")
   </code>
  The parameter being used here is <code>str</code>, which indicates that our expected input is a string.
</p>
<p>
   <code class="block">
     ; Template :
    (define (make-stop-sign str)
       (overlay
         (text ... ... ...)
         (regular-polygon ... ... ... ...)
         )
       )
   </code>
</p>
<p>
  <code class="block">
    ; Code :
    (define (make-stop-sign str)
      (overlay
        (text str 75 "white")
        (regular-polygon 100 8 "solid" "red")
      )
    )
   </code>
</p>

<div class="question">
  Challenge : Now that you know how to create a function that produces a stop sign, can you figure out how to build a similar function that instead produces a yield sign?
  <br>
  Here is an example you might use when completing the recipe.
  Note the expected output, which is the image you want your function to make.
</div>
<code class="block">
  ; Examples :
  (check-expect (make-yield-sign "YIELD") <img src="images/yield-sign.png" width="30%"> )
</code>

<!-- Section 3 -->

<h2 id="counterchange"> Counter-Change </h2>

<p>
  For our next challenge, we will use the recipe to write a counter-change function.
  A counter-change is when you have two images create a 2-by-2 checkerboard pattern with each image at opposite corners.
</p>

<p>
  As usual, the first step of the recipe is the purpose statement.
  Remember that the purpose should succinctly describe what the function is going to take as inputs, and what it will return.
  In this case, our function will take two images as inputs, and will return a single image of the original two images counter-changed.
  The following purpose statement captures the general idea effectively.
  <code class="block">
    ; Purpose : Given two images, return a checkerboard image comprised of those the two image arguments.
  </code>
</p>
<p>
  Next we create the signature.
  The signature should capture the purpose in terms of the data types that our function will take as inputs, and the datatype that it will return.
  In this case, our function will be taking two images, and then returning a single image based on the two input images.
  <code class="block">
    ; Signature : Image Image &rarr; Image
  </code>
</p>
<p>
  We need to create an example that will test our function.
  Recall that this step allows us to outline the exact specifications of our function, and to define what we want our function to return.
  The process of creating examples should also serves to provide us with a general outline for how our function will work.
  This will help us when it comes time to write code.
  <code class="block">
    ; Examples :
    (check-expect (make-counter-change (square 100 100 "red") (square 100 100 "cyan")) <img src="images/counter-change.png" width="50%"/>)
  </code>
</p>
<p>
  With our tests and examples in place, it is time to write the stub.
  Recall that the purpose of the stub is simply to get our tests to run, and not to pass.
  This will assure us that our function header is written correctly.
  <code class="block">
    ; Stub :
    (define (make-counter-change image-1 image-2) "checkerboard")
  </code>
</p>
<p>
  The next step in the recipe is to construct a template.
  The template should be a skeleton of what our eventual function will look like.
  We need to consider what functions we may need to use to get our intended output.
  Most likely, we will need to stack two rows of images to create the full image.
  For this we can use the <code>above</code> function.
  It requires two arguments, which we can fill in later.
  <code class="block">
  ; Template :
  (define (make-counter-change image-1 image-2)
    (above
      ...
      ...
    )
  )
  </code>
  We could move on to the coding step of the recipe at this point, but let's see if we can make our template slighty more detailed.
  <br>
  The above function will stack two rows, but how might we make the rows themselves?
  Each row needs to be two images next to each other.
  The <code>beside</code> takes two images and places the second beside the first.
  Given what our template looks like right now, we can replace the empty arguments with this function.
  <br>
  Do you see how this template will stack two rows of images once it is filled out?
  <code class="block">
  ; Template :
  (define (make-counter-change image-1 image-2)
    (above
      (beside ... ...)
      (beside ... ...)
    )
  )
  </code>
</p>
<p>
  Now it is time to code our function.
  The benefit of using the recipe is that we should have already gone through the process of creating a template, and the only thing left to do is fill it in with the appropriate parameters.
</p>
<p>
  Check out our code below for the <code>make-counter-change</code> function.
  Did you write it the same way?
  <code class="block">
    ; Code :
    (define (make-counter-change image-1 image-2)
      (above
        (beside image-2 image-1)
        (beside image-1 image-2)
        )
      )
  </code>
</p>
<div class="question">
  You can, of course, use this function with any images.
  <br>
  Try it with the folowing two images:
  <img src="images/peach1.png"/>
  <img src="images/cherry1.png"/>
</div>
<div class="question">
  Challenge : Using these two images, can you alter the function you just made so when it returns the final image, all images are oriented like they are in this <code>check-expect</code>?
  <br>
  Hint: use <code>flip-horizontal</code>.
</div>
<code class="block">
  (check-expect (flip-counter-change <img src="images/peach1.png" width="30%"/> <img src="images/cherry1.png" width="30%"/>) <img src="images/counter-cherry-peach.png" width="50%"/>)
</code>

<!-- Section 4 -->

<h2 id="bulls-eye"> Bulls-Eye </h2>

<p>
  For our next example, we will create a function that takes two colors as string inputs, and returns a dart-board of concentric circles, with each circle alternating in color.
  The dart-board should have a radius of 100 pixels, and each concentric circle should have a radius that is 10 pixels less than the previous circle.
</p>
<p>
  As usual, we begin with our purpose.
  This will help us make sure that we know how our function should behave.
  <code class="block">
    ; Purpose : Given two colors, return an image of a bulls-eye comprised of those colors.
  </code>
</p>
<p>
  Our purpose statement should have hopefully made it clear that our function will need two colors as inputs.
  Available preset colors are given as <code>strings</code>.
  For clarity, we can note that the <code>string</code> inputs represent colors.
  Our function will return an image.
  <code class="block">
    ; Signature : String String &rarr; Image, where all strings are colors
  </code>
</p>
<p>
  Next we create an example to test our function, following the same format as in previous challenges.
  <code class="block">
    ; Examples :
    (check-expect (make-bulls-eye "hotpink" "deepskyblue") <img src="images/bulls-eye.png" width="30%"/>)
  </code>
</p>
<p>
  With our example written, we are ready to create the stub and check if the examples are able to run.
  It is in the stub that we will name the the parameters our function will take.
</p>
<p>
  Try running with the stub below.
  The examples should execute successfully, even though our function will fail.
  <code class="block">
    ; Stub :
    (define (make-bulls-eye color-1 color-2) "bulls-eye")
  </code>
</p>
<p>
  With the example successfully executing when we run the code, we are ready to create a template of our function.
</p>
<p>
  For our template, we need to consider what functions will be necessary to build the image of a bulls-eye.
  We need to create many circles, and layer them on top of each other.
  <br>
  The <code>circle</code> function will definitely be used.
  Placing the circles on top of one another could be accomplished using a couple different functions, but in our example we are going to use <code>overlay</code>.
  Remember that <code>overlay</code> requires at least two images as arguments, and the <code>circle</code> function requires three.
  <br>
  Knowing this, we can create the following template:
  <code class="block">
    ; Template :
    (define (make-bulls-eye color-1 color-2)
      (overlay
        (circle ... ... ...)
        (circle ... ... ...)
        )
      )
  </code>
  We don't need to worry about what the circles will look like yet, or how many we will use.
  We can take care of that when we code our function, which is next.
</p>
<p>
  Looking at our example, how many circles will be required to make the expected image?
  <br>
  Let's add spaces for those, before we fill out the details of each one.
  <code class="block">
    ; Code :
    (define (make-bulls-eye color-1 color-2)
      (overlay
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        (circle ... ... ...)
        )
      )
  </code>
  Now we need to specify the arguments for each circle.
  Looking at our example again, all the circles are solid, so we can specify that first.
  <code class="block">
    ; Code :
    (define (make-bulls-eye color-1 color-2)
      (overlay
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        (circle ... "solid" ...)
        )
      )
  </code>
  Recall that the outermost circle will have a radius of 100 pixels, and the other circles will be decreasing by 10 pixels in each iteration.
  Can we add the color at the same time, since we know each circle will alternate in color?
  <code class="block">
    ; Code :
    (define (make-bulls-eye color-1 color-2)
      (overlay
        (circle 10 "solid" color-1)
        (circle 20 "solid" color-2)
        (circle 30 "solid" color-1)
        (circle 40 "solid" color-2)
        (circle 50 "solid" color-1)
        (circle 60 "solid" color-2)
        (circle 70 "solid" color-1)
        (circle 80 "solid" color-2)
        (circle 90 "solid" color-1)
        (circle 100 "solid" color-2)
        )
      )
  </code>
</p>
<div class="question">
  What image would you expect to see if you replaced the function <code>overlay</code> with <code>beside</code>?
  How about <code>above</code>?
</div>
<div class="question">
  Challenge : Make a function that produces a bulls-eye that, instead of alternating colors, appears as a gradient.
  Use this example:
</div>
<code class="block">
  (check-expect (make-bulls-eye-gradient "darkviolet") <img src="images/bulls-eye-tr.png" width="50%"/>)
</code>

<!-- Section 5 -->

<h2 id="pinwheel">Pinwheel</h2>

<p>
  For the next challenge, we will write a function that takes an image and creates a "pinwheel" of four copies of that image rotated around a corner of the original image.
</p>
<p>
  As usual, the first step in the recipe is to summarize the purpose of our function.
  Based on the description of the challenge, our function will take one image, and return another image based on the original image.
  Let's see if we can capture that idea in a single sentence.
  <code class="block">
    ; Purpose : Given a shape or image, return a 'pinwheel' comprised of that image.
  </code>
</p>
<p>
  The signature for this function should reflect that the function will take one image and return another image.
  Keep in mind that even though the image our function returns will consist of four copies of the original image,
  it will still be a single image.
  <code class="block">
    ; Signature : Image &rarr; Image
  </code>
</p>
<p>
  Now we must perform the critical step of creating examples to test what our function will return.
  Let's use a rhombus to test our function, since it will be evident if the individual elements of our pinwheel are not aligned properly if the width and height of our test image is different.
  <code class="block">
    ; Examples :
    (check-expect (make-pinwheel (rhombus 50 80 "solid" "turquoise")) <img src="images/turq-pinwheel.png"/>)
  </code>
</p>
<p>
  The stub will test that our examples work.
  Remember that our function will only take a single image as an argument.
  We will have our stub return a string to guarantee that our tests fail.
  All we want to verify is that they successfully run.
  <code class="block">
    ; Stub :
    (define (make-pinwheel image) "pinwheel")
  </code>
</p>
<p>
  We are almost ready to code, but first we need to create the template
  A properly constructed template should provide a basic outline of our function.
  <br>
  The image that we want to produce is similar to an image we produced with an earlier function.
  Remember how we made the template for <code>make-counter-change</code>?
  <code class="block">
  ; Template :
  (define (make-pinwheel image)
    (above
      (beside ... ...)
      (beside ... ...)
    )
  )
  </code>
  There are some differences between that function and the one we are building here, and our template should reflect that.
  If we were to use a rhombus as the input in <code>make-counter-change</code>, each shape will be oriented the same way.
  What we need to do is rotate each rhombus, which can be accomplished using the <code>rotate</code> function.
  We also need to rotate the whole image.
  There are a couple ways we could orient the images properly, but lets start with this template:
  <code class="block">
    ; Template :
    (define (make-pinwheel image)
      (rotate ...
        (above
          (beside
            (rotate ... ...)
            (rotate ... ...)
            )
          (beside
            (rotate ... ...)
            (rotate ... ...)
            )
        )
      )
    )
  </code>
</p>
<p>
  Now we can fully code our function.
  The first argument the <code>rotate</code> function requires is the number of degrees you want the image to be rotated.
  A positive value will rotate the image to the right, and a negative value will rotate the image to the left.
  We want our rhombus to be rotated 45 degrees, but in each row, one will be rotated to the left, and one will be rotated to the right.
  The final image will also be rotated 45 degrees.
  <code class="block">
    ; Code :
    (define (make-pinwheel image)
      (rotate -45
          (above
           (beside
              (rotate 45 image)
              (rotate -45 image)
            )
           (beside
              (rotate -45 image)
              (rotate 45 image)
            )
           )
          )
  )
  </code>
  Before you run your code, can you picture how the resulting image will look?
  It is helpful to visualize what you expect your function will return.
</p>
<p>
  Let's try something we haven't done before: produce an image, then use our function on that image.
  <br>
  Here is how we would produce the image we used for our example:
  <code class="block">
    (make-pinwheel (rhombus 50 80 "solid" "turquoise"))
  </code>
  We can use this as an argument for the same function, like so:
  <code class="block">
    (make-pinwheel (make-pinwheel (rhombus 50 80 "solid" "turquoise")))
  </code>
</p>
<p>
  Is this the image you created?
  <img src="images/double-turq-pinwheel.png"/>
</p>
<p>
  We can repeat this process as many times as we want to create an interesting pattern:
  <img src="images/double-double-turq-pinwheel.png"/>
</p>
<div class="question">
  Challenge : Create a function that produces a pinwheel comprised of four different images, as in this example:
</div>
<code class="block">
  (check-expect (make-rainbow-pinwheel (rhombus 50 80 "solid" "hotpink") (rhombus 50 80 "solid" "gold") (rhombus 50 80 "solid" "springgreen") (rhombus 50 80 "solid" "mediumslateblue")) <img src="images/rainbow-pinwheel.png"/>)
</code>
<div class="question">
  Bonus : What happens when you use this image as an argument in the first pinwheel function? Why does it look like this?
</div>
<img src="images/double-rainbow-pinwheel.png"/>

<!-- Section 6 -->

<h2 id="business-card"> Business Card </h2>

<p>
  For the next challenge, we will be creating a function that produces a business card.
  The card should have an ID picture, a logo, a name, and a job title.
  This challenge will let us practice using many of the placement functions we learned about in the graphics chapter here.    <!-- add link -->
  You can substitute your own picture, logo, and text for the ones we are using.
</p>
<p>
  Here are the images we will be using for our ID and logo respectively:
  <img src="images/pigeon1.png"/>
  <img src="images/purpleplanet.png"/>
  Let's define them so we can use them later.
  <code class="block">
    (define pigeon <img src="images/pigeon1.png"/>)
  </code>
  <code class="block">
    (define planet-logo <img src="images/purpleplanet.png"/>)
  </code>
</p>
<p>
  As usual, the first step of the recipe is the purpose.
  <code class="block">
    ; Purpose : Given an identifying image, a logo, a name, and a job, return a business card.
  </code>
</p>
<p>
  We have quite a few datatypes we will be working with, so lets take stock before we go further:
  <ul>
    <li>The identifying image and logo will clearly be <code>images</code>.</li>
    <li>The name and job will be <code>strings</code>.</li>
    <li>The complete business card will be an <code>image</code>.</li>
  </ul>
</p>
<p>
  We can list all of these datatypes in our signature.
  <code class="block">
    ; Signature : Image Image String String &rarr; Image
  </code>
</p>
<p>
  Next we create our example.
  <code class="block">
    ; Examples :
    (check-expect (print-business-card pigeon planet-logo " Dr. Feathers" "Galactic President"))
  </code>
</p>
<p>
  With our example in place, we can create a stub.
  <code class="block">
    ; Stub :
    (define (business-card id logo name job) 0)
  </code>
</p>
<p>
  Before we start writing the code for our function, we need to create a template.
  The design of our business card will have the ID picture on the left side, and the logo toward the upper right.
  The name and job title will be centered on the card, slightly toward the right.
  There are a few ways we could align and place the images together, so let's just work our way up.
  We can start with the text, which will be in two lines.
  <code class="block">
    ; Template :
    (define (business-card id logo name job)
      (above
        (text ... ... ...)
        (text ... ... ...)
      )
    )
  </code>
  We know also that the text will need to be placed alongside the ID picture, so we can do that next.
  <code class="block">
    ; Template :
    (define (business-card id logo name job)
      (beside ...
        (above
          (text ... ... ...)
          (text ... ... ...)
        )
      )
    )
  </code>
  The only thing left to add is the logo.
  Since it requires fairly precise placement, we can use a function like <code>overlay/align/offset</code>, which lets us very exactly specify where to put the logo.
  <code class="block">
    ; Template :
    (define (business-card id logo name job)
      (overlay/align/offset ... ...
        (beside ...
          (above
            (text ... ... ...)
            (text ... ... ...)
            )
          )
          ... ...
        )
      )
  </code>
</p>
<p>
  Now we can finally code the function we need.
  You will notice that we will need to use a few different placement functions to get the code just right.
  <code class="block">
    ; Code :
    (define (business-card id logo name job)
      (overlay/align/offset "right" "top"
        logo
        5 -10
        (overlay/offset
          (beside
            (place-image
              id
              115 100
              (rectangle 175 225 "solid" "white")
              )
            (above
              (text name 36 "black")
              (text/font job 24 "dimgray" #f 'roman 'italic 'normal #f)
              )
            )
          40 0
            (rectangle 500 250 "solid" "whitesmoke")
          )
        )
      )
  </code>
</p>

  <img src="images/pigeon-crop.png"/>

  <img src="images/business-card.png"/>


<!-- Section 7 -->

<h2 id="clock-face"> Clock Face </h2>

<!-- Update code for face and for place and turn function -->

<p>
  As our last challenge in this chapter, we will attempt to create a clock face.
  In our particular implementation, the numbers 1-12 on the clock-face should be oriented relative to the center of the dial, with 12 at the top. This challenge will require us to do more than simply place images a certain way.
  Though we could write one long function that handles every facet of this challenge, we will instead do our best to divide this challenge into several smaller challenges that we will then handle separately.
  This approach to programming is called "divide and conquer", and you will recall that it was one of our motivations for using the HtDF recipe to begin with.
  Large problems are often dealt with much more effectively if they are broken down into several smaller problems.
</p>
<p>
  To begin, let's create the blank clock-face. To avoid having to re-create it each time
  we would like to draw the clock face, we can define a constant to hold the image of
  our blank clock-face.
</p>
  <code class="block">
    (define clock-face
      (circle 130 "solid" "white")
    )
  </code>
  <p>
    Here we have define the constant <code>clock-face</code> to bind to the image of a white circle with a radius of 130 pixels.
    This is our blank clock face on which we'll place our numbers.
  </p>
  <p>
    Now that we have our clock face, it would be nice to place some numbers on it.
    However, we do not currently have any images of numbers that we could use.
    Remember, <code>Number</code> is a data type in Racket that is different than the <code>Image</code> data type.
    If we would like to have numbers on our clock face, we need to have images of the numbers that we can position on our clock face.
    This leads us to the first part of our challenge.
    We need a function that takes a number and returns an image of that number.
  </p>
  <p>
    As with any function, we begin by concisely stating our purpose:
  </p>
  <code class="block">
    ; Purpose : Given a number, return an image of that number.
  </code>
  <p>
    As usual, next comes the signature.
    This will serve as a guide to anyone who would like to use our function.
    We can also fall back to the signature if we lose our way.
  </p>
  <code class="block">
    ; Signature : Number &rarr; Image
  </code>
  <p>
    Now we will define some examples of how we expect our function to work.
    Click here to see the code that was used to create the example image.
    We will want our function to return an image for any number entered.
  </p>
  <code class="block">
    ; Examples :
    (check-expect (print-digit "12") <img src="images/digit.png"/>)
  </code>
  <p>
    With our examples defined, we have now defined what success looks like for our function.
    The next step in the recipe is to see if we can get the examples to execute.
    This will at least assure us that our function header is correct.
  </p>
  <code class="block">
    ; Stub :
    (define (print-digit num) 0)
  </code>
  <p>
    With our function header executing correctly, we are almost ready to begin coding our function.
    First, we need to write our function template.
    This will act as an inventory so that we know the general structure our function should follow.
    Our function should definitely use the <code>num</code> argument, so we should include it in the body of our template.
  </p>
  <code class="block">
    ; Template :
    (define (digit num)
      (
      ... num ...
      )
    )
  </code>
  <p>
    We are now ready to code our first function in this challenge.
    Remember that our function should take a number input, and somehow convert it to an image.
    Hint: you may need to convert your number to a string first.
  </p>
  <code class="block">
    ; Code :
    (define (digit num)
      (text/font (number->string num) 30 "black" #f "swiss" "normal" "bold" #f)
    )
  </code>
  <p>
    Congratulations! We now have a function that takes a number, and return an image of that number.
    This is a big step, but we're not there yet.
    We now need to somehow arrange the numbers 1 through 12 around the clock face.
  </p>
  <p>
    There are many possible ways we could go about this.
    The method we will use here will have us placing a number, starting with 1, at the top of the clock face, and then rotating the clock face some amount, and then placing the next number at the top of the face.
    Repeating this process for all 12 numbers should produce a fully-numbered clock face.
  </p>
  <p>
    As always, we want to divide-and-conquer this task if at all possible.
    Let's start with the simpler task of placing an image (in our case, of an image) on the top of the clock face, and then rotating it by the appropriate amount.
  </p>
  <p>
    The first thing to figure out is how much we would like to rotate the clock face, once the number is placed.
    A quick refresher of geometry will remind us that a circle has 360 degrees.
    We would like to place 12 numbers at approximately equal intervals, so the clock face should rotate 30 degrees between the placement of each number.
  </p>
  <p>
    At this point, we can write the purpose of our next function.
  </p>
  <code class="block">
    ; Purpose : Given a number and an image of a clock face, return an image of the number overlayed on the clock face, both rotated +30 degrees.
  </code>
  <p>
    The following signature should reflect the datatypes that our function will input and return, based on the purpose statement.
  </p>
  <code class="block">
    ; Signature : Number Image &rarr; Image
  </code>
  <p>
    Now let's come up with some examples.
    Something to keep in mind is that our function returns an image of a clock face with a number on it.
    This new image could now be used as the face input for the function when we want to place the number 2.
    Can you see how this might be used to fill up our clock face with all the numbers?
    You can see the code we used here.
  </p>
  <code class="block">
    ; Examples :
    (check-expect (place-turn 12 clock-face) <img src="images/place-turn.png"/>)   <!-- Should start with 1, 2, 3... otherwise clock is backwards -->
  </code>
  <p>
    Let's see if we can get our test to run.
    Make sure the inputs match the signature.
  </p>
  <code class="block">
    ; Stub :
    (define (place-turn str face) 0)    <!--Recommend change function name to place-num-and-rotate - DB -->
  </code>
  <p>
  Great!
  We got our examples to run.
  We're almost there.
</p>
  <code class="block">
    ; Template :
    (define (place-turn str face)
      (rotate ...
        (overlay/align ... ... ... ...)
      )
    )
  </code>
 <p>
 At this point, we're ready to code our function.
 Do you see how the function <code>digit</code> has helped us keep our code clean?
 </p>
  <code class="block">
    ; Code :
    (define (place-turn str face)
      (rotate 30
        (overlay/align
          "middle" "top"
          (digit str)
          face
        )
      )
    )
  </code>
   <p>
     Very well done!
     Our functions our coming together nicely, and we are just a few steps away from creating a fully numbered clock face.
     At this point, we have a function that takes a number and converts it into an <code>Image</code>.
     We have another function that takes a number and a clock face, places the number on the top of the clock face, and returns the clock face rotated 30 degrees to make room for the next number.
   </p>
   <p>
     Now we just need a function that places each number 1 through 12 and returns an <code>Image</code> of the fully-numbered clock face.
     We have already seen how, after we place the number 1 on the clock face, we can feed the new clock face directly into our function again to place the number 2.
     Our new function will need to go through and place each number 1 through 12 in a similar way.
   </p>
   <p>
     You may recall that there is a certain equivalence between images and functions that return the data type <code>Image</code>.
     If a function takes an <code>Image</code> as an argument, we can cut and paste the actual image graphic into the code, or we can input a function that returns an <code>Image</code>.
     We'll see how this feature could prove to be very useful.
   </p>
   <p>
     The purpose of our last function will be to take a clock face and populate it with numbers.
   </p>
  <code class="block">
    ; Purpose : Given a clock face image, return an image of the numbers 1-12 placed on the clock face.
  </code>
  <p>
    The only input is the image of the clock face.
    You might be tempted to think that we need to include a list of the numbers we want on the clock face.
    But we already know which numbers we want (1-12).
    There really is no additional input that we need to include besides the clock face itself.
  </p>
  <code class="block">
    ; Signature : Image &rarr; Image
  </code>
  <p>
   The signature reflects this simplicity nicely.
  </p>
  <code class="block">
    ; Examples :
    (check-expect (place-numbers clock-face) <img src="images/place-numbers.png"/>)
  </code>
  <p>
    Let's get our examples to run with the stub.
  </p>
  <code class="block">
    ; Stub :
    (define (place-numbers face) 0)
  </code>
  <code class="block">
    ; Template :
    (define (place-numbers face)
      (... face ...)
    )
  </code>
  <code class="block">
    ; Code :
    (define (place-numbers face)
      (rotate -30
        (foldl place-turn face
          '("1" "2" "3" "4" "5" "6" "7" "8" "9" "10" "11" "12")
        )
      )
    )
  </code>

  <code class="block">
    ; Code :
    (define (clock face)
      (overlay
        (place-numbers face)
        (circle 150 "outline" "black")
      )
    )
  </code>

  <img src="images/clock.png"/>

<!-- Challenge: adding hands to the clock face -->

<!-- Footer -->

<div class="footer">
  <h4>Copywright Notice</h6>
  <p>MIT License
    <br/><br/>
    Copyright (c) 2018 Mesa-Racketeers
    <br/><br/>
    <i>
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    <br/><br/>
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    <br/><br/>
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    </i>
  </p>
</div>

</body>
</html>
